---
ID: "f8a608aa-da64-45c4-a76e-bef0272d31d5"
Parent: "e22d066a-04d0-4799-9dad-edd9eb07c2b2"
Template: "dd22f1b3-bd87-4db2-9e7d-f7a496888d43"
Path: /sitecore/system/Modules/PowerShell/Script Library/SPE/Core/Platform/Functions/Remoting2
DB: master
SharedFields:
- ID: "b1a94ff0-6897-47c0-9c51-aa6acb80b1f0"
  Hint: Script
  Value: |
    <#
        .SYNOPSIS
            Sitecore PowerShell Extensions Remoting v2. 
            Use the SPE Remoting module found as a separate download and install in your module path.
            
        .DESCRIPTION
            The second version of the SPE remoting. This version uses a session object with a cached version of the web service proxy.
            The session object is also Windows security aware. Each function below contains help documentation.
        
        .LINK
            https://msdn.microsoft.com/en-us/library/dd878350(v=vs.85).aspx
            
        .LINK
            https://msdn.microsoft.com/en-us/library/dd878326(v=vs.85).aspx
    #>
    
    function New-ScriptSession {
        <#
            .SYNOPSIS
                Creates a new script session in Sitecore PowerShell Extensions via web service calls.
        
            .EXAMPLE
                The following remotely connects to an instance of Sitecore initializes a session.
                
                New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
        
                Username      : admin
                Password      : b
                ConnectionUri : http://concentrasitecore/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx
                SessionId     : 528b9865-a69e-4875-919f-12209646c934
                Credential    : 
                Proxy         : Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1Services_RemoteAutomation_asmx.RemoteAutomation
        #>
        param(
            [Parameter(Mandatory = $true)]
            [ValidateNotNullOrEmpty()]
            [string]$Username = $null,
    
            [Parameter(Mandatory = $true)]
            [ValidateNotNullOrEmpty()]
            [string]$Password = $null,
    
            [Parameter(Mandatory = $true)]
            [ValidateNotNullOrEmpty()]
            [Uri[]]$ConnectionUri = $null,
    
            [Parameter(Mandatory = $false)]
            [System.Management.Automation.PSCredential]
            $Credential
        )
        
        begin {
            $sessionId = [guid]::NewGuid()
            $session = @{
                "Username" = [string]$Username
                "Password" = [string]$Password
                "SessionId" = [string]$sessionId
                "Credential" = [System.Management.Automation.PSCredential]$Credential
                "Connection" = @()
            }
        }
    
        process {
    
            foreach($uri in $ConnectionUri) {
    
                $script = {
                    Get-ScriptSession -Current
                }
    
                if(!$uri.AbsoluteUri.EndsWith(".asmx")) {
                    $uri = "$($uri.AbsoluteUri.TrimEnd('/'))/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx"
                }
    
                $proxyProps = @{
                    Uri = $uri
                }
    
                if($Credential) {
                    $proxyProps["Credential"] = $Credential
                }
    
                $proxy = New-WebServiceProxy @proxyProps
                if($Credential) {
                    $proxy.Credentials = $Credential
                }
                if(-not $proxy) { return $null }
    
                $response = $proxy.ExecuteScriptBlock2($Username, $Password, $script.ToString(), $null, $SessionId)
                $serverSession = ConvertFrom-CliXml -InputObject $response
    
                if([guid]::TryParse($serverSession.ID, [ref] $sessionId)) {
                    $session["Connection"] += @(
                        [PSCustomObject]@{
                            Uri = [Uri]$uri
                            Proxy = [PSObject]$proxy
                        })
                } else {
                    Write-Error -Message "There was a problem creating a new script session."
                }
            }
        }
        
        end {
            [PSCustomObject]$session
        }
    }
    
    function Invoke-RemoteScript {
        <#
            .SYNOPSIS
                Run scripts in Sitecore PowerShell Extensions via web service calls.
        
            .EXAMPLE
                The following example remotely executes a script in Sitecore using a reusable session.
        
                $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
                Invoke-RemoteScript -Session $session -ScriptBlock { Get-User -id admin }
        
                Name                     Domain       IsAdministrator IsAuthenticated
                ----                     ------       --------------- ---------------
                sitecore\admin           sitecore     True            False
        
            .EXAMPLE
                The following remotely executes a script in Sitecore with arguments.
                
                $script = {
                    [Sitecore.Security.Accounts.User]$user = Get-User -Identity admin
                    $user
                    $params.date.ToString()
                }
        
                $args = @{
                    "date" = [datetime]::Now
                }
        
                Invoke-RemoteScript -ConnectionUri "http://remotesitecore" -Username "admin" -Password "b" -ScriptBlock $script -ArgumentList $args
        
                Name                     Domain       IsAdministrator IsAuthenticated
                ----                     ------       --------------- ---------------
                sitecore\admin           sitecore     True            False          
                6/25/2015 11:09:17 AM
        #>
        
        [CmdletBinding(DefaultParameterSetName="InProcess")]
        param(
            
            [Parameter(ParameterSetName='InProcess')]
            [Parameter(ParameterSetName='Session')]
            [Parameter(ParameterSetName='Uri')]
            [scriptblock]$ScriptBlock,
    
            [Parameter(ParameterSetName='Session')]
            [ValidateNotNull()]
            [pscustomobject]$Session,
    
            [Parameter(ParameterSetName='Uri')]
            [Uri[]]$ConnectionUri,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$SessionId,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$Username,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$Password,
    
            [Parameter(ParameterSetName='Uri')]
            [System.Management.Automation.PSCredential]
            $Credential,
            
            [Parameter()]
            [Alias("ArgumentList")]
            [hashtable]$Arguments
        )
    
        if($PSCmdlet.ParameterSetName -eq "InProcess") {
            $ScriptBlock.Invoke()
        } else {
            if($PSCmdlet.ParameterSetName -eq "Session") {
                $Username = $Session.Username
                $Password = $Session.Password
                $SessionId = $Session.SessionId
                $Credential = $Session.Credential
                $Connection = $Session.Connection
            } else {
                $Connection = $ConnectionUri | ForEach-Object { [PSCustomObject]@{ Uri = [Uri]$_; Proxy = $null } }
            }
            
            foreach($singleConnection in $Connection) {
                if(!$singleConnection.Uri.AbsoluteUri.EndsWith(".asmx")) {
                    $singleConnection.Uri = [Uri]"$($singleConnection.Uri.AbsoluteUri.TrimEnd('/'))/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx"
                }
        
                if(!$singleConnection.Proxy) {
                    $proxyProps = @{
                        Uri = $singleConnection.Uri
                    }
        
                    if($Credential) {
                        $proxyProps["Credential"] = $Credential
                    }
        
                    $singleConnection.Proxy = New-WebServiceProxy @proxyProps
                    if($Credential) {
                        $singleConnection.Proxy.Credentials = $Credential
                    }
                }
                if(-not $singleConnection.Proxy) { return $null }
        
                if($Arguments) {
                    $parameters = ConvertTo-CliXml -InputObject $Arguments
                }
                
                $response = $singleConnection.Proxy.ExecuteScriptBlock2($Username, $Password, $ScriptBlock.ToString(), $parameters, $SessionId)
                if($response) {
                    ConvertFrom-CliXml -InputObject $response
                }
            }
        }
    }
    
    function Send-MediaItem {
        <#
            .SYNOPSIS
                Uploads an item to the media library in Sitecore PowerShell Extensions via web service calls.
        
           .EXAMPLE
                The following uploads all of the images in a directory to the specified path in the media library in the master db.
                
                $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
                Get-ChildItem -Path C:\Images | Send-MediaItem -Session $session -Destination "/sitecore/media library/Images/"
        
            .EXAMPLE
                The following uploads a single image with a new name to the specified path in the media library in the master db.
        
                $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
                Send-MediaItem -Session $session -Path C:\Images\banner.jpg -Destination "/sitecore/media library/Images/banner.jpg"
        #>
        [CmdletBinding()]
        param(
            [Parameter(ParameterSetName='Session')]
            [ValidateNotNull()]
            [pscustomobject]$Session,
    
            [Parameter(ParameterSetName='Uri')]
            [Uri[]]$ConnectionUri,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$SessionId,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$Username,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$Password,
    
            [Parameter(ParameterSetName='Uri')]
            [System.Management.Automation.PSCredential]
            $Credential,
    
            [Parameter(Position=0, Mandatory=$true, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
            [Alias("FullName")]
            [ValidateNotNullOrEmpty()]
            [string]$Path,
            
            [Parameter(Position=1, Mandatory=$true)]
            [Alias("RemotePath")]
    		[ValidateNotNullOrEmpty()]
            [String]$Destination,
    
            [Parameter(Position=2)]
            [String]$Database = "master",
    
            [Parameter(Position=3)]
            [String]$Language = "en"
        )
    
        process {
            
            if($PSCmdlet.ParameterSetName -eq "Session") {
                $Username = $Session.Username
                $Password = $Session.Password
                $SessionId = $Session.SessionId
                $Credential = $Session.Credential
                $Connection = $Session.Connection
            } else {
                $Connection = $ConnectionUri | ForEach-Object { [PSCustomObject]@{ Uri = [Uri]$_; Proxy = $null } }
            }
    
            foreach($singleConnection in $Connection) {
                if(!$singleConnection.Uri.AbsoluteUri.EndsWith(".asmx")) {
                    $singleConnection.Uri = [Uri]"$($singleConnection.Uri.AbsoluteUri.TrimEnd('/'))/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx"
                }
        
                if(!$singleConnection.Proxy) {
                    $proxyProps = @{
                        Uri = $singleConnection.Uri
                    }
        
                    if($Credential) {
                        $proxyProps["Credential"] = $Credential
                    }
        
                    $singleConnection.Proxy = New-WebServiceProxy @proxyProps
                    if($Credential) {
                        $singleConnection.Proxy.Credentials = $Credential
                    }
                }
                if(-not $singleConnection.Proxy) { return $null }
    
                $output = $Destination
                $extension = [System.IO.Path]::GetExtension($Path)
                if(!$output.EndsWith($extension)) {
                    if(!$output.EndsWith("/") -and !$output.EndsWith("\")) {
                        $output += "/"
                    }
    
                    $output += [System.IO.Path]::GetFileName($Path)
                }
    	
                [byte[]]$bytes = [System.IO.File]::ReadAllBytes($Path)
    
                if($bytes -and $bytes.Length -gt 0) {
    
                    Write-Verbose -Message "Uploading $($Path)"
                    $singleConnection.Proxy.UploadFile($Username, $Password, $output, $bytes, $Database, $Language) | Out-Null
    
                    Write-Verbose -Message "Upload complete."
                } else {
                    Write-Verbose -Message "Upload failed. No content to send to the web service."
                }
            }
        }
    }
    
    function Receive-MediaItem {
        <#
            .SYNOPSIS
                Downloads an item from the media library in Sitecore PowerShell Extensions via web service calls.
        
           .EXAMPLE
                The following downloads an item from the media library in the master db and dynamically detects the file extension.
                Existing files will be deleted automatically.
        
                $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
                Receive-MediaItem -Session $session -Path "/sitecore/media library/Images/Icons/accuracy" -Destination C:\Images\ -Force
        
           .EXAMPLE
                The following downloads an item from the media library in the master db and uses the specified name.
        
                $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
                Receive-MediaItem -Session $session -Path "/sitecore/media library/Images/Icons/accuracy" -Destination C:\Images\accuracy2.jpg -Force
        
            .EXAMPLE
                The following downloads all the items from the media library in the specified path.
        
                $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
                Invoke-RemoteScript -Session $session -ScriptBlock { 
                    Get-ChildItem -Path "master:/sitecore/media library/Images/Icons/" | Select-Object -Expand ItemPath 
                } | Receive-MediaItem -Session $session -Destination C:\Temp\Images\
        #>
        [CmdletBinding()]
        param(
            [Parameter(ParameterSetName='Session')]
            [ValidateNotNull()]
            [pscustomobject]$Session,
    
            [Parameter(ParameterSetName='Uri')]
            [string[]]$ConnectionUri,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$SessionId,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$Username,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$Password,
    
            [Parameter(ParameterSetName='Uri')]
            [System.Management.Automation.PSCredential]
            $Credential,
    
            [Parameter(Position=0, Mandatory=$true, ValueFromPipeline=$true)]
            [ValidateNotNullOrEmpty()]
            [string]$Path,
            
            [Parameter(Position=1, Mandatory=$true)]
            [Alias("RemotePath")]
    		[ValidateNotNullOrEmpty()]
            [string]$Destination,
    
            [Parameter(Position=2)]
            [string]$Database = "master",
    
            [Parameter(Position=3)]
            [string]$Language = "en",
    
            [Parameter()]
            [switch]$Force
        )
        
        begin {
            function Get-ImageExtension {
                param(
                    [ValidateNotNullOrEmpty()]
                    [byte[]]$ImageData
                )
            
                $extension = ".jpg"
            
                Write-Verbose "The destination path is missing a file extension. Attempting to figure that out now."
                $memoryStream = New-Object System.IO.MemoryStream
                $memoryStream.Write($ImageData, 0, $ImageData.Length)
                $image = [System.Drawing.Image]::FromStream($memoryStream)
                switch($image.RawFormat.Guid) {
                    "b96b3cab-0728-11d3-9d7b-0000f81ef32e" {
                        $extension = ".bmp"
                        break
                    }
                    "b96b3cb0-0728-11d3-9d7b-0000f81ef32e" {
                        $extension = ".gif"
                        break
                    }
                    "b96b3cae-0728-11d3-9d7b-0000f81ef32e" {
                        $extension = ".jpg"
                        break
                    }
                    "b96b3caa-0728-11d3-9d7b-0000f81ef32e" {
                        $extension = ".bmp"
                        break
                    }
                    "b96b3caf-0728-11d3-9d7b-0000f81ef32e" {
                        $extension = ".png"
                        break
                    }
                }
                $memoryStream.Dispose()
                $image.Dispose()
            
                $extension
            }
        }
    
        process {
    
            if($PSCmdlet.ParameterSetName -eq "Session") {
                $Username = $Session.Username
                $Password = $Session.Password
                $SessionId = $Session.SessionId
                $Credential = $Session.Credential
                $Connection = $Session.Connection
            } else {
                $Connection = $ConnectionUri | ForEach-Object { [PSCustomObject]@{ Uri = [Uri]$_; Proxy = $null } }
            }
    
            foreach($singleConnection in $Connection) {
                if(!$singleConnection.Uri.AbsoluteUri.EndsWith(".asmx")) {
                    $singleConnection.Uri = [Uri]"$($singleConnection.Uri.AbsoluteUri.TrimEnd('/'))/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx"
                }
        
                if(!$singleConnection.Proxy) {
                    $proxyProps = @{
                        Uri = $singleConnection.Uri
                    }
        
                    if($Credential) {
                        $proxyProps["Credential"] = $Credential
                    }
        
                    $singleConnection.Proxy = New-WebServiceProxy @proxyProps
                    if($Credential) {
                        $singleConnection.Proxy.Credentials = $Credential
                    }
                }
                if(-not $singleConnection.Proxy) { return $null }
    
                Write-Verbose -Message "Downloading $($Path)"
                [byte[]]$response = $singleConnection.Proxy.DownloadFile($Username, $Password, $Path, $Database, $Language)
    	
                if($response -and $response.Length -gt 0) {
                    
                    $directory = [System.IO.Path]::GetDirectoryName($Destination)
                    if(!$directory) {
                        $directory = $Destination
                    }
                    
                    if(!(Test-Path $directory -PathType Container)) {
                        Write-Verbose "Creating a new directory $($directory)"
                        New-Item -ItemType Directory -Path $directory | Out-Null
                    }
    
                    $output = $Destination
    
                    $extension = [System.IO.Path]::GetExtension($output)
                    if(!$extension) {
                        $extension = Get-ImageExtension -ImageData $response
    
                        $name = [System.IO.Path]::GetFileName($Path.TrimEnd('\','/'))
                        $output = Join-Path -Path $output -ChildPath ($name + $extension)
                    }
                    
                    if(-not(Test-Path $output -PathType Leaf) -or $Force.IsPresent) {
                        Write-Verbose "Creating a new file $($output)"
                        New-Item -Path $output -ItemType File -Force | Out-Null
                        [System.IO.File]::WriteAllBytes((Convert-Path -Path $output), $response)
                    } else {
                        Write-Verbose "Skipping the save of $($output) because it already exists."
                    }
                    
                    Write-Verbose "Download complete."
                } else {
                    Write-Verbose -Message "Download failed. No content returned from the web service."
                }
            }
        }
    }
    
    function ConvertFrom-CliXml {
        param(
            [Parameter(Position=0, Mandatory=$true, ValueFromPipeline=$true)]
            [ValidateNotNullOrEmpty()]
            [String[]]$InputObject
        )
        begin
        {
            $OFS = "`n"
            [String]$xmlString = ""
        }
        process
        {
            $xmlString += $InputObject
        }
        end
        {
            $type = [PSObject].Assembly.GetType('System.Management.Automation.Deserializer')
            $ctor = $type.GetConstructor('instance,nonpublic', $null, @([xml.xmlreader]), $null)
            $sr = New-Object System.IO.StringReader $xmlString
            $xr = New-Object System.Xml.XmlTextReader $sr
            $deserializer = $ctor.Invoke($xr)
            $done = $type.GetMethod('Done', [System.Reflection.BindingFlags]'nonpublic,instance')
            while (!$type.InvokeMember("Done", "InvokeMethod,NonPublic,Instance", $null, $deserializer, @()))
            {
                try {
                    $type.InvokeMember("Deserialize", "InvokeMethod,NonPublic,Instance", $null, $deserializer, @())
                } catch {
                    Write-Warning "Could not deserialize ${string}: $_"
                }
            }
            $xr.Close()
            $sr.Dispose()
        }
    }
    
    function ConvertTo-CliXml {
        param(
            [Parameter(Position=0, Mandatory=$true, ValueFromPipeline=$true)]
            [ValidateNotNullOrEmpty()]
            [PSObject[]]$InputObject
        )
        begin {
            $type = [PSObject].Assembly.GetType('System.Management.Automation.Serializer')
            $ctor = $type.GetConstructor('instance,nonpublic', $null, @([System.Xml.XmlWriter]), $null)
            $sw = New-Object System.IO.StringWriter
            $xw = New-Object System.Xml.XmlTextWriter $sw
            $serializer = $ctor.Invoke($xw)
            #$method = $type.GetMethod('Serialize', 'nonpublic,instance', $null, [type[]]@([object]), $null)
        }
        process {
            try {
                [void]$type.InvokeMember("Serialize", "InvokeMethod,NonPublic,Instance", $null, $serializer, [object[]]@($InputObject))
            } catch {
                Write-Warning "Could not serialize $($InputObject.GetType()): $_"
            }
        }
        end {    
            [void]$type.InvokeMember("Done", "InvokeMethod,NonPublic,Instance", $null, $serializer, @())
            $sw.ToString()
            $xw.Close()
            $sw.Dispose()
        }
    }
Languages:
- Language: en
  Versions:
  - Version: 1
    Fields:
    - ID: "25bed78c-4957-4165-998a-ca1b52f67497"
      Hint: __Created
      Value: 20150713T165257
