----item----
version: 1
id: {F8A608AA-DA64-45C4-A76E-BEF0272D31D5}
database: master
path: /sitecore/system/Modules/PowerShell/Script Library/Platform/Functions/Remoting2
parent: {E22D066A-04D0-4799-9DAD-EDD9EB07C2B2}
name: Remoting2
master: {00000000-0000-0000-0000-000000000000}
template: {DD22F1B3-BD87-4DB2-9E7D-F7A496888D43}
templatekey: PowerShell Script

----field----
field: {B1A94FF0-6897-47C0-9C51-AA6ACB80B1F0}
name: Script
key: script
content-length: 21694

<#
    .SYNOPSIS
        Sitecore PowerShell Extensions Remoting v2. 
        Use the SPE Remoting module found as a separate download and install in your module path.
        
    .DESCRIPTION
        The second version of the SPE remoting. This version uses a session object with a cached version of the web service proxy.
        The session object is also Windows security aware. Each function below contains help documentation.
    
    .LINK
        https://msdn.microsoft.com/en-us/library/dd878350(v=vs.85).aspx
        
    .LINK
        https://msdn.microsoft.com/en-us/library/dd878326(v=vs.85).aspx
#>

function New-ScriptSession {
    <#
        .SYNOPSIS
            Creates a new script session in Sitecore PowerShell Extensions via web service calls.
    
        .EXAMPLE
            The following remotely connects to an instance of Sitecore initializes a session.
            
            New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
    
            Username      : admin
            Password      : b
            ConnectionUri : http://concentrasitecore/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx
            SessionId     : 528b9865-a69e-4875-919f-12209646c934
            Credential    : 
            Proxy         : Microsoft.PowerShell.Commands.NewWebserviceProxy.AutogeneratedTypes.WebServiceProxy1Services_RemoteAutomation_asmx.RemoteAutomation
    #>
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Username = $null,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Password = $null,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [Uri[]]$ConnectionUri = $null,

        [Parameter(Mandatory = $false)]
        [System.Management.Automation.PSCredential]
        $Credential
    )
    
    begin {
        $sessionId = [guid]::NewGuid()
        $session = @{
            "Username" = [string]$Username
            "Password" = [string]$Password
            "SessionId" = [string]$sessionId
            "Credential" = [System.Management.Automation.PSCredential]$Credential
            "Connection" = @()
        }
    }

    process {

        foreach($uri in $ConnectionUri) {

            $script = {
                Get-ScriptSession -Current
            }

            if(!$uri.AbsoluteUri.EndsWith(".asmx")) {
                $uri = "$($uri.AbsoluteUri.TrimEnd('/'))/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx"
            }

            $proxyProps = @{
                Uri = $uri
            }

            if($Credential) {
                $proxyProps["Credential"] = $Credential
            }

            $proxy = New-WebServiceProxy @proxyProps
            if($Credential) {
                $proxy.Credentials = $Credential
            }
            if(-not $proxy) { return $null }

            $response = $proxy.ExecuteScriptBlock2($Username, $Password, $script.ToString(), $null, $SessionId)
            $serverSession = ConvertFrom-CliXml -InputObject $response

            if([guid]::TryParse($serverSession.ID, [ref] $sessionId)) {
                $session["Connection"] += @(
                    [PSCustomObject]@{
                        Uri = [Uri]$uri
                        Proxy = [PSObject]$proxy
                    })
            } else {
                Write-Error -Message "There was a problem creating a new script session."
            }
        }
    }
    
    end {
        [PSCustomObject]$session
    }
}

function Invoke-RemoteScript {
    <#
        .SYNOPSIS
            Run scripts in Sitecore PowerShell Extensions via web service calls.
    
        .EXAMPLE
            The following example remotely executes a script in Sitecore using a reusable session.
    
            $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
            Invoke-RemoteScript -Session $session -ScriptBlock { Get-User -id admin }
    
            Name                     Domain       IsAdministrator IsAuthenticated
            ----                     ------       --------------- ---------------
            sitecore\admin           sitecore     True            False
    
        .EXAMPLE
            The following remotely executes a script in Sitecore with arguments.
            
            $script = {
                [Sitecore.Security.Accounts.User]$user = Get-User -Identity admin
                $user
                $params.date.ToString()
            }
    
            $args = @{
                "date" = [datetime]::Now
            }
    
            Invoke-RemoteScript -ConnectionUri "http://remotesitecore" -Username "admin" -Password "b" -ScriptBlock $script -ArgumentList $args
    
            Name                     Domain       IsAdministrator IsAuthenticated
            ----                     ------       --------------- ---------------
            sitecore\admin           sitecore     True            False          
            6/25/2015 11:09:17 AM
    #>
    
    [CmdletBinding(DefaultParameterSetName="InProcess")]
    param(
        
        [Parameter(ParameterSetName='InProcess')]
        [Parameter(ParameterSetName='Session')]
        [Parameter(ParameterSetName='Uri')]
        [scriptblock]$ScriptBlock,

        [Parameter(ParameterSetName='Session')]
        [ValidateNotNull()]
        [pscustomobject]$Session,

        [Parameter(ParameterSetName='Uri')]
        [Uri[]]$ConnectionUri,

        [Parameter(ParameterSetName='Uri')]
        [string]$SessionId,

        [Parameter(ParameterSetName='Uri')]
        [string]$Username,

        [Parameter(ParameterSetName='Uri')]
        [string]$Password,

        [Parameter(ParameterSetName='Uri')]
        [System.Management.Automation.PSCredential]
        $Credential,
        
        [Parameter()]
        [Alias("ArgumentList")]
        [hashtable]$Arguments
    )

    if($PSCmdlet.ParameterSetName -eq "InProcess") {
        $ScriptBlock.Invoke()
    } else {
        if($PSCmdlet.ParameterSetName -eq "Session") {
            $Username = $Session.Username
            $Password = $Session.Password
            $SessionId = $Session.SessionId
            $Credential = $Session.Credential
            $Connection = $Session.Connection
        } else {
            $Connection = $ConnectionUri | ForEach-Object { [PSCustomObject]@{ Uri = [Uri]$_; Proxy = $null } }
        }
        
        foreach($singleConnection in $Connection) {
            if(!$singleConnection.Uri.AbsoluteUri.EndsWith(".asmx")) {
                $singleConnection.Uri = [Uri]"$($singleConnection.Uri.AbsoluteUri.TrimEnd('/'))/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx"
            }
    
            if(!$singleConnection.Proxy) {
                $proxyProps = @{
                    Uri = $singleConnection.Uri
                }
    
                if($Credential) {
                    $proxyProps["Credential"] = $Credential
                }
    
                $singleConnection.Proxy = New-WebServiceProxy @proxyProps
                if($Credential) {
                    $singleConnection.Proxy.Credentials = $Credential
                }
            }
            if(-not $singleConnection.Proxy) { return $null }
    
            if($Arguments) {
                $parameters = ConvertTo-CliXml -InputObject $Arguments
            }
            
            $response = $singleConnection.Proxy.ExecuteScriptBlock2($Username, $Password, $ScriptBlock.ToString(), $parameters, $SessionId)
            if($response) {
                ConvertFrom-CliXml -InputObject $response
            }
        }
    }
}

function Send-MediaItem {
    <#
        .SYNOPSIS
            Uploads an item to the media library in Sitecore PowerShell Extensions via web service calls.
    
       .EXAMPLE
            The following uploads all of the images in a directory to the specified path in the media library in the master db.
            
            $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
            Get-ChildItem -Path C:\Images | Send-MediaItem -Session $session -Destination "/sitecore/media library/Images/"
    
        .EXAMPLE
            The following uploads a single image with a new name to the specified path in the media library in the master db.
    
            $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
            Send-MediaItem -Session $session -Path C:\Images\banner.jpg -Destination "/sitecore/media library/Images/banner.jpg"
    #>
    [CmdletBinding()]
    param(
        [Parameter(ParameterSetName='Session')]
        [ValidateNotNull()]
        [pscustomobject]$Session,

        [Parameter(ParameterSetName='Uri')]
        [Uri[]]$ConnectionUri,

        [Parameter(ParameterSetName='Uri')]
        [string]$SessionId,

        [Parameter(ParameterSetName='Uri')]
        [string]$Username,

        [Parameter(ParameterSetName='Uri')]
        [string]$Password,

        [Parameter(ParameterSetName='Uri')]
        [System.Management.Automation.PSCredential]
        $Credential,

        [Parameter(Position=0, Mandatory=$true, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
        [Alias("FullName")]
        [ValidateNotNullOrEmpty()]
        [string]$Path,
        
        [Parameter(Position=1, Mandatory=$true)]
        [Alias("RemotePath")]
		[ValidateNotNullOrEmpty()]
        [String]$Destination,

        [Parameter(Position=2)]
        [String]$Database = "master",

        [Parameter(Position=3)]
        [String]$Language = "en"
    )

    process {
        
        if($PSCmdlet.ParameterSetName -eq "Session") {
            $Username = $Session.Username
            $Password = $Session.Password
            $SessionId = $Session.SessionId
            $Credential = $Session.Credential
            $Connection = $Session.Connection
        } else {
            $Connection = $ConnectionUri | ForEach-Object { [PSCustomObject]@{ Uri = [Uri]$_; Proxy = $null } }
        }

        foreach($singleConnection in $Connection) {
            if(!$singleConnection.Uri.AbsoluteUri.EndsWith(".asmx")) {
                $singleConnection.Uri = [Uri]"$($singleConnection.Uri.AbsoluteUri.TrimEnd('/'))/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx"
            }
    
            if(!$singleConnection.Proxy) {
                $proxyProps = @{
                    Uri = $singleConnection.Uri
                }
    
                if($Credential) {
                    $proxyProps["Credential"] = $Credential
                }
    
                $singleConnection.Proxy = New-WebServiceProxy @proxyProps
                if($Credential) {
                    $singleConnection.Proxy.Credentials = $Credential
                }
            }
            if(-not $singleConnection.Proxy) { return $null }

            $output = $Destination
            $extension = [System.IO.Path]::GetExtension($Path)
            if(!$output.EndsWith($extension)) {
                if(!$output.EndsWith("/") -and !$output.EndsWith("\")) {
                    $output += "/"
                }

                $output += [System.IO.Path]::GetFileName($Path)
            }
	
            [byte[]]$bytes = [System.IO.File]::ReadAllBytes($Path)

            if($bytes -and $bytes.Length -gt 0) {

                Write-Verbose -Message "Uploading $($Path)"
                $singleConnection.Proxy.UploadFile($Username, $Password, $output, $bytes, $Database, $Language) | Out-Null

                Write-Verbose -Message "Upload complete."
            } else {
                Write-Verbose -Message "Upload failed. No content to send to the web service."
            }
        }
    }
}

function Receive-MediaItem {
    <#
        .SYNOPSIS
            Downloads an item from the media library in Sitecore PowerShell Extensions via web service calls.
    
       .EXAMPLE
            The following downloads an item from the media library in the master db and dynamically detects the file extension.
            Existing files will be deleted automatically.
    
            $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
            Receive-MediaItem -Session $session -Path "/sitecore/media library/Images/Icons/accuracy" -Destination C:\Images\ -Force
    
       .EXAMPLE
            The following downloads an item from the media library in the master db and uses the specified name.
    
            $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
            Receive-MediaItem -Session $session -Path "/sitecore/media library/Images/Icons/accuracy" -Destination C:\Images\accuracy2.jpg -Force
    
        .EXAMPLE
            The following downloads all the items from the media library in the specified path.
    
            $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
            Invoke-RemoteScript -Session $session -ScriptBlock { 
                Get-ChildItem -Path "master:/sitecore/media library/Images/Icons/" | Select-Object -Expand ItemPath 
            } | Receive-MediaItem -Session $session -Destination C:\Temp\Images\
    #>
    [CmdletBinding()]
    param(
        [Parameter(ParameterSetName='Session')]
        [ValidateNotNull()]
        [pscustomobject]$Session,

        [Parameter(ParameterSetName='Uri')]
        [string[]]$ConnectionUri,

        [Parameter(ParameterSetName='Uri')]
        [string]$SessionId,

        [Parameter(ParameterSetName='Uri')]
        [string]$Username,

        [Parameter(ParameterSetName='Uri')]
        [string]$Password,

        [Parameter(ParameterSetName='Uri')]
        [System.Management.Automation.PSCredential]
        $Credential,

        [Parameter(Position=0, Mandatory=$true, ValueFromPipeline=$true)]
        [ValidateNotNullOrEmpty()]
        [string]$Path,
        
        [Parameter(Position=1, Mandatory=$true)]
        [Alias("RemotePath")]
		[ValidateNotNullOrEmpty()]
        [string]$Destination,

        [Parameter(Position=2)]
        [string]$Database = "master",

        [Parameter(Position=3)]
        [string]$Language = "en",

        [Parameter()]
        [switch]$Force
    )
    
    begin {
        function Get-ImageExtension {
            param(
                [ValidateNotNullOrEmpty()]
                [byte[]]$ImageData
            )
        
            $extension = ".jpg"
        
            Write-Verbose "The destination path is missing a file extension. Attempting to figure that out now."
            $memoryStream = New-Object System.IO.MemoryStream
            $memoryStream.Write($ImageData, 0, $ImageData.Length)
            $image = [System.Drawing.Image]::FromStream($memoryStream)
            switch($image.RawFormat.Guid) {
                "b96b3cab-0728-11d3-9d7b-0000f81ef32e" {
                    $extension = ".bmp"
                    break
                }
                "b96b3cb0-0728-11d3-9d7b-0000f81ef32e" {
                    $extension = ".gif"
                    break
                }
                "b96b3cae-0728-11d3-9d7b-0000f81ef32e" {
                    $extension = ".jpg"
                    break
                }
                "b96b3caa-0728-11d3-9d7b-0000f81ef32e" {
                    $extension = ".bmp"
                    break
                }
                "b96b3caf-0728-11d3-9d7b-0000f81ef32e" {
                    $extension = ".png"
                    break
                }
            }
            $memoryStream.Dispose()
            $image.Dispose()
        
            $extension
        }
    }

    process {

        if($PSCmdlet.ParameterSetName -eq "Session") {
            $Username = $Session.Username
            $Password = $Session.Password
            $SessionId = $Session.SessionId
            $Credential = $Session.Credential
            $Connection = $Session.Connection
        } else {
            $Connection = $ConnectionUri | ForEach-Object { [PSCustomObject]@{ Uri = [Uri]$_; Proxy = $null } }
        }

        foreach($singleConnection in $Connection) {
            if(!$singleConnection.Uri.AbsoluteUri.EndsWith(".asmx")) {
                $singleConnection.Uri = [Uri]"$($singleConnection.Uri.AbsoluteUri.TrimEnd('/'))/sitecore%20modules/PowerShell/Services/RemoteAutomation.asmx"
            }
    
            if(!$singleConnection.Proxy) {
                $proxyProps = @{
                    Uri = $singleConnection.Uri
                }
    
                if($Credential) {
                    $proxyProps["Credential"] = $Credential
                }
    
                $singleConnection.Proxy = New-WebServiceProxy @proxyProps
                if($Credential) {
                    $singleConnection.Proxy.Credentials = $Credential
                }
            }
            if(-not $singleConnection.Proxy) { return $null }

            Write-Verbose -Message "Downloading $($Path)"
            [byte[]]$response = $singleConnection.Proxy.DownloadFile($Username, $Password, $Path, $Database, $Language)
	
            if($response -and $response.Length -gt 0) {
                
                $directory = [System.IO.Path]::GetDirectoryName($Destination)
                if(!$directory) {
                    $directory = $Destination
                }
                
                if(!(Test-Path $directory -PathType Container)) {
                    Write-Verbose "Creating a new directory $($directory)"
                    New-Item -ItemType Directory -Path $directory | Out-Null
                }

                $output = $Destination

                $extension = [System.IO.Path]::GetExtension($output)
                if(!$extension) {
                    $extension = Get-ImageExtension -ImageData $response

                    $name = [System.IO.Path]::GetFileName($Path.TrimEnd('\','/'))
                    $output = Join-Path -Path $output -ChildPath ($name + $extension)
                }
                
                if(-not(Test-Path $output -PathType Leaf) -or $Force.IsPresent) {
                    Write-Verbose "Creating a new file $($output)"
                    New-Item -Path $output -ItemType File -Force | Out-Null
                    [System.IO.File]::WriteAllBytes((Convert-Path -Path $output), $response)
                } else {
                    Write-Verbose "Skipping the save of $($output) because it already exists."
                }
                
                Write-Verbose "Download complete."
            } else {
                Write-Verbose -Message "Download failed. No content returned from the web service."
            }
        }
    }
}

function ConvertFrom-CliXml {
    param(
        [Parameter(Position=0, Mandatory=$true, ValueFromPipeline=$true)]
        [ValidateNotNullOrEmpty()]
        [String[]]$InputObject
    )
    begin
    {
        $OFS = "`n"
        [String]$xmlString = ""
    }
    process
    {
        $xmlString += $InputObject
    }
    end
    {
        $type = [PSObject].Assembly.GetType('System.Management.Automation.Deserializer')
        $ctor = $type.GetConstructor('instance,nonpublic', $null, @([xml.xmlreader]), $null)
        $sr = New-Object System.IO.StringReader $xmlString
        $xr = New-Object System.Xml.XmlTextReader $sr
        $deserializer = $ctor.Invoke($xr)
        $done = $type.GetMethod('Done', [System.Reflection.BindingFlags]'nonpublic,instance')
        while (!$type.InvokeMember("Done", "InvokeMethod,NonPublic,Instance", $null, $deserializer, @()))
        {
            try {
                $type.InvokeMember("Deserialize", "InvokeMethod,NonPublic,Instance", $null, $deserializer, @())
            } catch {
                Write-Warning "Could not deserialize ${string}: $_"
            }
        }
        $xr.Close()
        $sr.Dispose()
    }
}

function ConvertTo-CliXml {
    param(
        [Parameter(Position=0, Mandatory=$true, ValueFromPipeline=$true)]
        [ValidateNotNullOrEmpty()]
        [PSObject[]]$InputObject
    )
    begin {
        $type = [PSObject].Assembly.GetType('System.Management.Automation.Serializer')
        $ctor = $type.GetConstructor('instance,nonpublic', $null, @([System.Xml.XmlWriter]), $null)
        $sw = New-Object System.IO.StringWriter
        $xw = New-Object System.Xml.XmlTextWriter $sw
        $serializer = $ctor.Invoke($xw)
        #$method = $type.GetMethod('Serialize', 'nonpublic,instance', $null, [type[]]@([object]), $null)
    }
    process {
        try {
            [void]$type.InvokeMember("Serialize", "InvokeMethod,NonPublic,Instance", $null, $serializer, [object[]]@($InputObject))
        } catch {
            Write-Warning "Could not serialize $($InputObject.GetType()): $_"
        }
    }
    end {    
        [void]$type.InvokeMember("Done", "InvokeMethod,NonPublic,Instance", $null, $serializer, @())
        $sw.ToString()
        $xw.Close()
        $sw.Dispose()
    }
}
----version----
language: en
version: 1
revision: 29d30039-b9c8-445b-98af-b344f1b3e139

----field----
field: {25BED78C-4957-4165-998A-CA1B52F67497}
name: __Created
key: __created
content-length: 15

20150713T165257
----field----
field: {8CDC337E-A112-42FB-BBB4-4143751E123F}
name: __Revision
key: __revision
content-length: 36

29d30039-b9c8-445b-98af-b344f1b3e139
----field----
field: {D9CF14B1-FA16-4BA6-9288-E8A174D4D522}
name: __Updated
key: __updated
content-length: 34

20150715T044944:635725325845298453
----field----
field: {BADD9CF9-53E0-4D0C-BCC0-2D784C282F6A}
name: __Updated by
key: __updated by
content-length: 14

sitecore\admin
